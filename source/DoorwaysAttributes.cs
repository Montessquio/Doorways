using HarmonyLib;
using SecretHistories.Constants.Modding;
using SecretHistories.Entities;
using SecretHistories.Fucine;
using System;
using System.CodeDom;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Doorways
{

    /// <summary>
    /// Signals to Doorways that this class can be loaded
    /// as a Fucine Importable. It must be a child class of
    /// an existing Fucine class or a Doorways entity class.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public class DoorwaysObjectAttribute : Attribute { }

    /// <summary>
    /// A shorthand signal to Doorways that this enum
    /// can be used as a Fucine DeckSpec.
    /// Optionally, a default item may be specified.
    /// If no default item is specified, the
    /// deck will loop by default.
    /// <para />
    /// In order to specify deck text (for portal deckspecs)
    /// add the <see cref="DrawTextAttribute"/> attribute
    /// to each enum item.
    /// </summary>
    [AttributeUsage(AttributeTargets.Enum)]
    public class DeckAttribute : Attribute
    {
        public string defaultKey = null;
        public DeckAttribute() { }
        public DeckAttribute(string defaultKey)
        {
            this.defaultKey = defaultKey;
        }
    }

    /// <summary>
    /// Add this to a <see cref="DeckAttribute"/>
    /// enum in order to specify the text that
    /// will be shown then that card is pulled
    /// when the deck is drawn from as a portal
    /// deck.
    /// </summary>
    [AttributeUsage(AttributeTargets.All)]
    public class DrawTextAttribute : Attribute
    {
        string text;
        public DrawTextAttribute(string text)
        {
            this.text = text;
        }
    }

    /// <summary>
    /// <see cref="DoorwaysObjectAttribute"/>s that
    /// have methods tagged DoorwaysFactory
    /// can procedurally generate as many entities
    /// as they like at load time.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method)]
    public class DoorwaysFactoryAttribute : Attribute
    {
        /// <summary>
        /// Retrieve all the entities generated by this factory.
        /// </summary>
        public static IEnumerable<IEntityWithId> Invoke(MethodInfo m)
        {
            if (m.IsStatic == true
             && m.GetParameters().Length == 0
             && typeof(IEnumerable<IEntityWithId>).IsAssignableFrom(m.ReturnType))
            {
                return (IEnumerable<IEntityWithId>)m.Invoke(null, new object[] { });
            }
            else
            {
                throw new ArgumentException($"The method '{m.Name}' is not valid! Factory methods must have the signature \"static IEnumerable<IEntityWithId> Func(void)!\"");
            }
        }
    }

    /// <summary>
    /// Define the root namespace all your mod objects will be defined in.
    /// If it's not present, the namespace will be the same as mod's ID.
    /// </summary>
    [AttributeUsage(AttributeTargets.Assembly)]
    public class DoorwaysAttribute : Attribute
    {
        public string Name = null;
        public string Prefix = null;

        public DoorwaysAttribute() { }
    }

    /// <summary>
    /// The attached static method should be run when the mod is loaded.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method)]
    public class DoorwaysInitAttribute : Attribute
    {
        private static bool AsksForVoid(MethodInfo m)
        {
            if (m.IsStatic == false)
            {
                return false;
            }

            ParameterInfo[] p = m.GetParameters();
            if (p.Length == 0)
            {
                return true;
            }
            return false;
        }

        private static bool AsksForInterface(MethodInfo m)
        {
            if (m.IsStatic == false)
            {
                return false;
            }

            ParameterInfo[] p = m.GetParameters();
            if (p.Length == 1)
            {
                if (typeof(IDoorwaysPlugin).IsAssignableFrom(p[0].GetType()))
                {
                    return true;
                }
            }
            return false;
        }

        internal static void Invoke(MethodInfo m, IDoorwaysPlugin p)
        {
            if (AsksForVoid(m))
            {
                m.Invoke(null, new object[] { });
            }
            else if (AsksForInterface(m))
            {
                m.Invoke(null, new object[] { p });
            }
            throw new ArgumentException($"The method '{m.Name}' is not valid! Initializer methods must be marked static void and have either no parameters or a single parameter assignable from IDoorwaysPlugin!");
        }
    }

    /// <summary>
    /// The attached class' members which shadow the matching
    /// method or property in the parameter class will forcibly
    /// override the shadowed members in the provided class.
    /// </summary>
    public interface IInheritOverride<T> { }

    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    public class DFucineHandlerAttribute : Attribute
    {
        public string EntityTag;
        public DFucineHandlerAttribute(string entityTag)
        {
            EntityTag = entityTag;
        }

        internal static void Initialize()
        {
            DoorwaysPlugin self = new DoorwaysPlugin(Assembly.GetExecutingAssembly());
            self.ModPrefix = "doorways";
            self.ModName = "doorways";
            self.Name = "doorwaystypehandler";
            self.Prefix = "doorways";

            Initialize(self);
        }

        public static void Initialize(DoorwaysPlugin forMod)
        {
            var _span = Logger.Instance.Span();
            IEnumerable<(MethodInfo, DFucineHandlerAttribute)> methods = from t in forMod.PluginAssembly.GetTypes()
                                              from m in t.GetMethods()
                                              where m.GetCustomAttribute<DFucineHandlerAttribute>() != null
                                              select (m, m.GetCustomAttribute<DFucineHandlerAttribute>());

            foreach ((MethodInfo m, DFucineHandlerAttribute attr) in methods)
            {
                if (!typeof(IEntityWithId).IsAssignableFrom(m.ReturnType))
                {
                    _span.Error($"Method '{m.DeclaringType}::{m.Name}' must have a return value that is assignable to IEntityWithId!");
                    continue;
                }
                var p = m.GetParameters();
                if (!(
                      p.Length == 2
                   && typeof(LoadedDataFile).IsAssignableFrom(p[0].ParameterType)
                   && typeof(IDoorwaysMod).IsAssignableFrom(p[1].ParameterType)
                   && m.IsStatic
                ))
                {
                    _span.Error("A Fucine Import handler must have the signature 'static IEntityWithId Func((LoadedDataFile, IDoorwaysMod)'!");
                    continue;
                }

                var parameters = p.Select(p => Expression.Parameter(p.ParameterType, p.Name)).ToArray();
                var dele = Expression.Lambda(
                    Expression.Call(
                        Expression.Constant(null),
                        m,
                        parameters
                    ), 
                    parameters
                ).Compile();

                CustomEntity.RegisterNewType($"{forMod.ModName}/{forMod.Name}", attr.EntityTag, (CustomEntity.EntityConstructor)dele);
            }
        }
    }
}
